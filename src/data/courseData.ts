export interface Command {
  cmd: string;
  desc: string;
}

export interface DayContent {
  day: number;
  title: string;
  description: string;
  theory: string;
  commands: Command[];
  mission: string;
}

export const courseData: DayContent[] = [
  {
    day: 1,
    title: "Вступ до Linux",
    description: "Чому Linux критично важливий для військових систем.",
    theory: "Linux — це операційна система з відкритим вихідним кодом, яка є стандартом де-факто для серверів, вбудованих систем, дронів, маршрутизаторів та засобів радіоелектронної боротьби (РЕБ). На відміну від комерційних ОС (як Windows), Linux дозволяє повний аудит вихідного коду, що виключає наявність прихованих бекдорів. Для військових це означає абсолютний контроль над обладнанням. Система побудована на принципі модульності: ви встановлюєте лише те, що потрібно для виконання бойової задачі, що мінімізує поверхню атаки та споживання ресурсів. Розуміння архітектури Linux — це базовий навик для будь-якого фахівця з кібербезпеки, зв'язківця або оператора БПЛА.",
    commands: [
      { cmd: "uname -a", desc: "Вивести інформацію про ядро та систему." },
      { cmd: "whoami", desc: "Показати ім'я поточного користувача." },
      { cmd: "date", desc: "Показати поточну дату та час системи." }
    ],
    mission: "Відкрийте термінал, перевірте версію ядра вашої системи та переконайтеся, під яким користувачем ви працюєте. Це перший крок до контролю над машиною."
  },
  {
    day: 2,
    title: "Орієнтування на місцевості (Навігація)",
    description: "Навігація у файловій системі Linux.",
    theory: "Файлова система Linux має сувору ієрархічну структуру у вигляді перевернутого дерева. Абсолютно все в системі починається з кореневого каталогу, який позначається символом '/'. У Linux діє правило 'все є файлом' — навіть апаратні пристрої (диски, термінали, мережеві інтерфейси) представлені як файли у спеціальних директоріях (наприклад, /dev). Розуміння цієї структури критично важливе: конфігурації завжди лежать у /etc, лог-файли та змінні дані — у /var, а виконувані програми — у /bin та /usr/bin. Вміння швидко орієнтуватися в цій структурі через термінал дозволяє оперативно знаходити потрібну інформацію під час інцидентів або налаштування обладнання в польових умовах.",
    commands: [
      { cmd: "pwd", desc: "Print Working Directory - показати поточний шлях." },
      { cmd: "ls -l", desc: "Показати вміст директорії у вигляді детального списку." },
      { cmd: "cd /var/log", desc: "Перейти до директорії з логами системи." },
      { cmd: "cd ..", desc: "Повернутися на один рівень вище." }
    ],
    mission: "Знайдіть своє поточне місцезнаходження, перейдіть у кореневу директорію '/', перегляньте її вміст, а потім поверніться у свою домашню директорію ('cd ~')."
  },
  {
    day: 3,
    title: "Робота з розвідданими (Файли та директорії)",
    description: "Створення, копіювання та переміщення файлів.",
    theory: "В умовах бойових дій інформація є критичним ресурсом. У Linux управління даними здійснюється виключно через команди, що забезпечує швидкість та можливість автоматизації. Ви повинні вміти миттєво створювати резервні копії конфігурацій перед внесенням змін (щоб мати можливість відкату), структурувати розвіддані по директоріях та безповоротно знищувати компрометовані файли. Важливо пам'ятати, що команда `rm` видаляє файли назавжди, без 'кошика', тому її використання вимагає максимальної концентрації. Правильна організація файлів та директорій на сервері чи портативному пристрої прискорює доступ до даних та зменшує ризик помилок під стресом.",
    commands: [
      { cmd: "mkdir intel", desc: "Створити нову директорію 'intel'." },
      { cmd: "touch report.txt", desc: "Створити порожній файл 'report.txt'." },
      { cmd: "cp report.txt intel/", desc: "Скопіювати файл у директорію." },
      { cmd: "mv report.txt secret.txt", desc: "Перейменувати або перемістити файл." },
      { cmd: "rm secret.txt", desc: "Видалити файл (ОБЕРЕЖНО, безповоротно)." }
    ],
    mission: "Створіть директорію 'mission_alpha', створіть у ній файл 'targets.txt', зробіть його копію 'targets_backup.txt', а потім видаліть оригінал."
  },
  {
    day: 4,
    title: "Перегляд вмісту (Читання файлів)",
    description: "Як читати текстові файли без їх редагування.",
    theory: "Читання файлів без ризику їх модифікації — це основа безпечної роботи з конфігураціями та логами. Коли ви підключаєтесь до сервера для траблшутингу (пошуку несправностей), вам потрібно аналізувати текстові дані. Утиліта `cat` підходить для коротких файлів, але для великих логів вона марна. Тут на допомогу приходять `less` (для зручної навігації великими документами), `head` (для перевірки заголовків) та `tail`. Команда `tail -f` є абсолютно незамінною: вона дозволяє в реальному часі спостерігати за тим, як система записує нові події у лог-файл, що ідеально підходить для моніторингу атак, перевірки з'єднань або відстеження статусу розгортання сервісів.",
    commands: [
      { cmd: "cat file.txt", desc: "Вивести весь вміст файлу на екран." },
      { cmd: "less file.txt", desc: "Посторінковий перегляд великого файлу (вихід - клавіша 'q')." },
      { cmd: "head -n 10 file.txt", desc: "Показати перші 10 рядків файлу." },
      { cmd: "tail -n 20 file.txt", desc: "Показати останні 20 рядків (корисно для логів)." },
      { cmd: "tail -f /var/log/syslog", desc: "Слідкувати за оновленням файлу в реальному часі." }
    ],
    mission: "Знайдіть будь-який великий текстовий файл у системі (наприклад, /var/log/auth.log) та перегляньте його останні 15 рядків, щоб побачити останні події автентифікації."
  },
  {
    day: 5,
    title: "Пошук цілей (find та locate)",
    description: "Пошук файлів у системі за різними критеріями.",
    theory: "Пошук інформації на скомпрометованому або незнайомому сервері вимагає точних інструментів. Команда `find` — це не просто пошук за іменем, це потужний радар, який дозволяє фільтрувати файлову систему за десятками критеріїв: розміром, датою модифікації, власником, правами доступу та типом. Наприклад, ви можете знайти всі файли, змінені за останні 10 хвилин (можливі сліди атаки), або всі файли з правами виконання. `locate` працює інакше — він шукає миттєво по заздалегідь створеній базі даних, що корисно для швидкого пошуку відомих файлів, але може не показати щойно створені об'єкти. Володіння цими інструментами значно скорочує час реакції на інциденти.",
    commands: [
      { cmd: "find / -name 'secret.txt'", desc: "Шукати файл за точним іменем по всій системі." },
      { cmd: "find . -type d", desc: "Знайти всі директорії у поточній папці." },
      { cmd: "find /var/log -mtime -1", desc: "Знайти файли, змінені за останні 24 години." },
      { cmd: "locate bashrc", desc: "Швидкий пошук за базою даних (потребує оновлення updatedb)." }
    ],
    mission: "Використайте команду find у вашій домашній директорії, щоб знайти всі файли з розширенням '.txt', які були змінені за останні 7 днів."
  },
  {
    day: 6,
    title: "Аналіз перехоплень (grep)",
    description: "Пошук тексту всередині файлів.",
    theory: "Утиліта `grep` (Global Regular Expression Print) — це скапель для роботи з текстом. У військових системах ви часто стикаєтесь з гігабайтами логів, конфігурацій або перехоплених даних. Знайти потрібну IP-адресу, MAC-адресу або повідомлення про помилку вручну неможливо. `grep` дозволяє миттєво витягувати рядки, що відповідають певному шаблону. Більше того, він підтримує регулярні вирази (Regex), що дозволяє створювати надзвичайно складні фільтри. Вміння ефективно використовувати `grep` відрізняє новачка від професіонала: ви можете швидко ізолювати сліди несанкціонованого доступу, відфільтрувати потрібні параметри з конфігурацій або проаналізувати мережевий трафік.",
    commands: [
      { cmd: "grep 'ERROR' /var/log/syslog", desc: "Знайти всі рядки з текстом 'ERROR' у файлі." },
      { cmd: "grep -i 'password' config.txt", desc: "Пошук без урахування регістру." },
      { cmd: "grep -r '192.168.1.1' /etc/", desc: "Рекурсивний пошук тексту у всіх файлах директорії." },
      { cmd: "grep -v 'DEBUG' app.log", desc: "Показати всі рядки, що НЕ містять 'DEBUG'." }
    ],
    mission: "Проаналізуйте файл /etc/passwd і знайдіть рядок, що стосується вашого користувача (grep 'ваше_імя' /etc/passwd)."
  },
  {
    day: 7,
    title: "Конвеєри та перенаправлення (Pipes)",
    description: "Об'єднання команд для створення потужних ланцюжків.",
    theory: "Конвеєри (Pipes) та перенаправлення вводу/виводу — це те, що робить командний рядок Linux таким потужним. Замість створення складних монолітних програм, Linux пропонує набір простих утиліт, які можна з'єднувати між собою як блоки конструктора. Символ `|` (pipe) бере результат (вивід) однієї команди і передає його як вхідні дані для наступної. Наприклад, ви можете взяти список усіх процесів, передати його в `grep` для фільтрації, а потім в `wc` для підрахунку кількості. Перенаправлення (`>`, `>>`) дозволяє зберігати результати роботи команд у файли для подальшого аналізу або створення звітів. Це основа автоматизації та обробки великих масивів розвідданих.",
    commands: [
      { cmd: "echo 'Secret data' > file.txt", desc: "Записати текст у файл (перезапис)." },
      { cmd: "echo 'More data' >> file.txt", desc: "Додати текст у кінець файлу." },
      { cmd: "ls -l /etc | less", desc: "Передати вивід ls у less для зручного читання." },
      { cmd: "cat /var/log/auth.log | grep 'Failed' | wc -l", desc: "Порахувати кількість невдалих спроб входу." }
    ],
    mission: "Виведіть список всіх процесів (ps aux), відфільтруйте його за допомогою grep, щоб знайти процеси 'root', і збережіть результат у файл 'root_processes.txt'."
  },
  {
    day: 8,
    title: "Маскування та доступи (chmod, chown)",
    description: "Основи безпеки: управління правами доступу до файлів.",
    theory: "Безпека файлової системи (Permissions) — це фундаментальний механізм захисту в Linux. Кожен файл і директорія мають три рівні доступу: для власника (User), для групи (Group) та для всіх інших (Others). Для кожного рівня можна встановити права на читання (r), запис (w) та виконання (x). У військовому контексті неправильно налаштовані права — це критична вразливість. Наприклад, якщо приватний SSH-ключ має права на читання для 'інших', система відмовиться його використовувати з міркувань безпеки. Принцип мінімальних привілеїв (PoLP) вимагає, щоб кожен файл мав рівно стільки прав, скільки необхідно для його роботи, і не більше. Команди `chmod` (зміна прав) та `chown` (зміна власника) є основними інструментами забезпечення цього принципу.",
    commands: [
      { cmd: "ls -la", desc: "Переглянути права доступу (напр., -rwxr-xr--)." },
      { cmd: "chmod 700 secret_script.sh", desc: "Дати повні права лише власнику (rwx------)." },
      { cmd: "chmod 640 config.cfg", desc: "Власник: читання/запис, група: читання, інші: нічого." },
      { cmd: "chown root:root file.txt", desc: "Змінити власника та групу файлу на root." }
    ],
    mission: "Створіть файл 'operation_plan.txt'. Змініть його права так, щоб тільки ви могли його читати та редагувати, а всі інші не мали жодного доступу (chmod 600). Перевірте результат за допомогою ls -la."
  },
  {
    day: 9,
    title: "Особовий склад та Привілеї (Користувачі, sudo)",
    description: "Основи безпеки: управління обліковими записами та захист системи.",
    theory: "Управління доступом (Identity and Access Management) є критичним для захисту інфраструктури. У Linux суперкористувач `root` має абсолютну владу над системою. Працювати постійно під `root` категорично заборонено, оскільки будь-яка помилка або шкідливий скрипт можуть знищити систему. Замість цього створюються звичайні користувачі, яким за потреби надаються тимчасові привілеї через утиліту `sudo`. Це забезпечує підзвітність: кожна дія через `sudo` записується в системний журнал (лог), що дозволяє провести аудит і з'ясувати, хто саме змінив конфігурацію або видалив дані. Правильне налаштування груп користувачів дозволяє гнучко керувати доступом до різних проектів та секретних матеріалів.",
    commands: [
      { cmd: "sudo useradd -m -s /bin/bash operator1", desc: "Створити користувача з домашньою директорією та оболонкою bash." },
      { cmd: "sudo passwd operator1", desc: "Встановити пароль для користувача." },
      { cmd: "sudo usermod -aG sudo operator1", desc: "Надати права адміністратора через групу sudo." },
      { cmd: "su - operator1", desc: "Переключитися на іншого користувача." },
      { cmd: "sudo visudo", desc: "Безпечне редагування файлу налаштувань sudoers." }
    ],
    mission: "Створіть нового користувача 'comms_officer'. Додайте його до групи 'sudo'. Переключіться на цього користувача та спробуйте виконати команду 'sudo ls /root', щоб перевірити, чи працюють його адміністративні привілеї."
  },
  {
    day: 10,
    title: "Контроль ресурсів (Управління процесами)",
    description: "Моніторинг та зупинка програм.",
    theory: "Кожна запущена програма або скрипт у Linux стає 'процесом', який отримує унікальний ідентифікатор (PID) та споживає системні ресурси (CPU, RAM). У бойових умовах сервери часто працюють на межі своїх можливостей. Якщо ворожий скрипт, помилка в програмі або DDoS-атака перевантажують систему, вона може перестати відповідати на запити. Оператор повинен вміти швидко оцінити стан системи за допомогою моніторів (`top`, `htop`), виявити процеси-паразити та безжально їх завершити за допомогою сигналів (`kill`). Розуміння станів процесів (running, sleeping, zombie) та вміння керувати ними у фоновому режимі (jobs, fg, bg) є необхідним для підтримки безперебійної роботи вузлів зв'язку.",
    commands: [
      { cmd: "top", desc: "Інтерактивний монітор процесів (аналог диспетчера завдань)." },
      { cmd: "htop", desc: "Більш зручна та кольорова версія top (може потребувати встановлення)." },
      { cmd: "ps aux", desc: "Вивести список усіх запущених процесів." },
      { cmd: "kill 1234", desc: "Відправити сигнал завершення процесу з PID 1234." },
      { cmd: "kill -9 1234", desc: "Примусово (безжально) знищити процес." }
    ],
    mission: "Запустіть команду 'sleep 1000 &' у фоновому режимі. Знайдіть її PID за допомогою 'ps aux | grep sleep' та знищіть процес за допомогою 'kill'."
  },
  {
    day: 11,
    title: "Озброєння (Управління пакетами)",
    description: "Встановлення та оновлення програмного забезпечення.",
    theory: "На відміну від Windows, де програми часто завантажуються зі сторонніх сайтів, Linux використовує централізовані репозиторії та пакетні менеджери (наприклад, APT для Debian/Ubuntu/Kali). Це гарантує, що програмне забезпечення перевірене, криптографічно підписане та не містить шкідливого коду. Пакетний менеджер автоматично вирішує проблеми із залежностями (встановлює додаткові бібліотеки, необхідні для роботи програми). Регулярне оновлення системи (`apt update` та `apt upgrade`) є найважливішим кроком у захисті від відомих вразливостей (CVE). У військових мережах часто створюють власні, локальні (дзеркальні) репозиторії, щоб оновлювати системи без доступу до глобального інтернету.",
    commands: [
      { cmd: "sudo apt update", desc: "Оновити список доступних пакетів (розвідка)." },
      { cmd: "sudo apt upgrade", desc: "Оновити всі встановлені програми до нових версій." },
      { cmd: "sudo apt install nmap", desc: "Встановити нову програму (наприклад, мережевий сканер nmap)." },
      { cmd: "sudo apt remove nmap", desc: "Видалити програму." }
    ],
    mission: "Оновіть списки пакетів вашої системи та встановіть утиліту 'htop' або 'tree', якщо вони ще не встановлені."
  },
  {
    day: 12,
    title: "Логістика (Архівація та стиснення)",
    description: "Пакування файлів для передачі.",
    theory: "Ефективне управління даними вимагає вміння їх стискати та архівувати. У польових умовах пропускна здатність каналів зв'язку (наприклад, супутникових або радіорелейних) часто обмежена і нестабільна. Передача тисяч дрібних файлів займає набагато більше часу і частіше обривається, ніж передача одного великого файлу. Утиліта `tar` (Tape Archive) використовується для об'єднання багатьох файлів і директорій в один архів, а алгоритми стиснення (gzip, bzip2, xz) значно зменшують його розмір. Вміння швидко запакувати розвіддані, лог-файли або конфігурації для передачі в штаб, а також розпакувати отримані оновлення — це базова навичка логістики даних.",
    commands: [
      { cmd: "tar -cvf archive.tar /path/to/dir", desc: "Створити архів з директорії (без стиснення)." },
      { cmd: "tar -czvf archive.tar.gz /path/to/dir", desc: "Створити стиснутий архів (gzip)." },
      { cmd: "tar -xzvf archive.tar.gz", desc: "Розпакувати стиснутий архів." },
      { cmd: "zip -r data.zip /path/to/dir", desc: "Створити zip-архів." }
    ],
    mission: "Створіть директорію з кількома текстовими файлами, запакуйте її в архів .tar.gz, видаліть оригінальну директорію, а потім розпакуйте архів назад."
  },
  {
    day: 13,
    title: "Зв'язок та Координація (Основи мереж)",
    description: "Перевірка з'єднання та маршрутизації.",
    theory: "Мережева взаємодія — це кровоносна система сучасної війни. Кожен пристрій у мережі має IP-адресу та використовує таблиці маршрутизації для визначення шляху передачі пакетів. Коли зв'язок зникає, оператор повинен діяти за чітким алгоритмом траблшутингу: 1) перевірити власні інтерфейси (`ip a`), 2) перевірити доступність шлюзу та цілі (`ping`), 3) проаналізувати маршрут і знайти точку обриву (`traceroute`). Команда `ping` використовує протокол ICMP і є базовим індикатором 'життя' вузла, тоді як `traceroute` показує кожен маршрутизатор на шляху до цілі, що дозволяє зрозуміти, чи проблема на вашому боці, у провайдера, чи мережа заглушена засобами РЕБ.",
    commands: [
      { cmd: "ip a", desc: "Показати всі мережеві інтерфейси та їх IP-адреси (сучасний аналог ifconfig)." },
      { cmd: "ping -c 4 8.8.8.8", desc: "Перевірити доступність вузла. Сценарій: перевірка зв'язку з ретранслятором." },
      { cmd: "traceroute 8.8.8.8", desc: "Показати маршрут пакетів. Сценарій: виявлення вузла, на якому обривається зв'язок." },
      { cmd: "ip route", desc: "Показати таблицю маршрутизації (шлюз за замовчуванням)." }
    ],
    mission: "Визначте IP-адресу вашого основного мережевого інтерфейсу. Виконайте ping до відомого надійного вузла (наприклад, 1.1.1.1) та використайте traceroute, щоб побачити, через скільки проміжних вузлів проходить ваш сигнал."
  },
  {
    day: 14,
    title: "Радіоелектронна розвідка (Аналіз мережі)",
    description: "Аналіз портів та виявлення аномальних з'єднань.",
    theory: "Комп'ютерні мережі використовують порти (від 1 до 65535) для розділення трафіку різних програм. Відкритий порт — це потенційні двері для атаки. Утиліти `ss` та `netstat` дозволяють провести радіоелектронну розвідку власної системи: побачити, які сервіси очікують на підключення (LISTEN), і які з'єднання вже встановлені (ESTABLISHED). Якщо ви бачите невідомий процес, що передає дані на підозрілу зовнішню IP-адресу, це може бути ознакою компрометації (троян або бекдор). Регулярний аудит відкритих портів та активних з'єднань є обов'язковим для підтримки кібергігієни та безпеки командних пунктів.",
    commands: [
      { cmd: "ss -tuln", desc: "Показати всі відкриті порти, що слухають TCP/UDP. Перевірка на зайві сервіси." },
      { cmd: "netstat -antp", desc: "Показати активні з'єднання та процеси. Потребує sudo для показу PID." },
      { cmd: "nc -vz 192.168.1.10 22", desc: "Перевірити, чи відкритий порт на іншій машині (напр., доступність SSH на дроні)." },
      { cmd: "curl ifconfig.me", desc: "Дізнатися свою зовнішню (публічну) IP-адресу." }
    ],
    mission: "Використайте 'sudo netstat -antp' або 'sudo ss -tulpn'. Знайдіть усі процеси, які зараз 'слухають' мережу (LISTEN). Переконайтеся, що ви знаєте призначення кожного з цих процесів (наприклад, sshd)."
  },
  {
    day: 15,
    title: "Дистанційне керування (SSH)",
    description: "Безпечне підключення до віддалених систем.",
    theory: "Протокол SSH (Secure Shell) є абсолютним стандартом для віддаленого адміністрування в Linux. На відміну від застарілих протоколів (як Telnet), SSH шифрує весь трафік, включаючи паролі та команди, що робить перехоплення даних (sniffing) марним для ворога. Для максимальної безпеки замість паролів використовується автентифікація за криптографічними ключами (публічний/приватний ключ). Приватний ключ зберігається лише у вас і ніколи не передається мережею, а публічний розміщується на серверах, до яких потрібен доступ. Це не тільки захищає від атак типу 'brute-force' (перебір паролів), але й дозволяє автоматизувати процеси, надаючи скриптам безпечний доступ до інших машин.",
    commands: [
      { cmd: "ssh user@10.0.0.5", desc: "Підключитися до віддаленої машини за IP-адресою." },
      { cmd: "ssh -p 2222 user@10.0.0.5", desc: "Підключитися, використовуючи нестандартний порт." },
      { cmd: "ssh-keygen", desc: "Згенерувати пару криптографічних ключів (публічний/приватний) для входу без пароля." },
      { cmd: "ssh-copy-id user@10.0.0.5", desc: "Скопіювати публічний ключ на віддалений сервер." }
    ],
    mission: "Згенеруйте власну пару SSH-ключів за допомогою 'ssh-keygen' (залиште налаштування за замовчуванням). Перегляньте свій публічний ключ: 'cat ~/.ssh/id_rsa.pub'."
  },
  {
    day: 16,
    title: "Безпечна передача (scp та rsync)",
    description: "Копіювання файлів між системами.",
    theory: "Передача файлів між системами повинна бути такою ж безпечною, як і віддалене управління. Утиліта `scp` (Secure Copy) використовує протокол SSH для шифрування даних під час передачі, що робить її ідеальною для разового копіювання файлів. Однак для регулярної синхронізації великих обсягів даних (наприклад, бекапів або баз даних розвідки) незамінним є `rsync`. Його головна перевага — дельта-алгоритм: він порівнює файли на джерелі та приймачі і передає лише ті частини файлів, які змінилися. Це колосально економить трафік і час, що критично важливо при роботі через повільні або нестабільні канали зв'язку (Starlink під РЕБ, радіомодеми).",
    commands: [
      { cmd: "scp report.txt user@10.0.0.5:/tmp/", desc: "Скопіювати локальний файл на віддалений сервер." },
      { cmd: "scp user@10.0.0.5:/var/log/syslog ./", desc: "Завантажити файл з віддаленого сервера." },
      { cmd: "rsync -avz ./data/ user@10.0.0.5:/backup/", desc: "Синхронізувати директорію (передає лише змінені файли, стискає трафік)." }
    ],
    mission: "Ознайомтесь із синтаксисом rsync. Це найефективніший спосіб передачі великих обсягів розвідданих при нестабільному зв'язку."
  },
  {
    day: 17,
    title: "Система попередження (Логи та journalctl)",
    description: "Читання системних журналів.",
    theory: "Системні журнали (логи) — це детальний літопис всього, що відбувається в операційній системі. Будь-яка помилка обладнання, збій програми, успішний чи неуспішний вхід користувача — все це фіксується. Сучасні дистрибутиви Linux використовують систему ініціалізації `systemd`, яка включає компонент `journald` для централізованого збору та управління логами. Утиліта `journalctl` дозволяє зручно фільтрувати ці записи за часом, сервісом або пріоритетом. Вміння читати логи — це головна навичка при розслідуванні інцидентів безпеки (наприклад, виявлення спроб підбору пароля до SSH) та діагностиці несправностей (наприклад, чому не запускається VPN-клієнт).",
    commands: [
      { cmd: "journalctl -xe", desc: "Переглянути останні записи логів (з розширеним описом помилок)." },
      { cmd: "journalctl -u ssh", desc: "Показати логи конкретного сервісу (наприклад, SSH)." },
      { cmd: "journalctl --since '1 hour ago'", desc: "Показати логи за останню годину." },
      { cmd: "dmesg | tail", desc: "Показати повідомлення ядра (корисно при підключенні нового обладнання)." }
    ],
    mission: "Використайте 'journalctl -u ssh' (або sshd), щоб перевірити логи служби SSH. Шукайте рядки 'Failed password', щоб побачити невдалі спроби входу."
  },
  {
    day: 18,
    title: "Польова хірургія (Текстові редактори)",
    description: "Редагування файлів у терміналі.",
    theory: "Більшість серверів та вбудованих систем (дрони, маршрутизатори) працюють без графічного інтерфейсу (GUI) для економії ресурсів та зменшення поверхні атаки. Тому вміння редагувати текстові файли безпосередньо в терміналі є життєво необхідним. `nano` — це простий та інтуїтивно зрозумілий редактор, ідеальний для швидких правок. `vim` (Vi IMproved) — це професійний інструмент з крутою кривою навчання, але він встановлений практично на кожній Linux-системі у світі за замовчуванням. `vim` працює в різних режимах (командний, вставки, візуальний), що дозволяє редагувати текст з неймовірною швидкістю без використання миші. Знання базових команд `vim` врятує вас у ситуаціях, коли інші редактори недоступні.",
    commands: [
      { cmd: "nano config.txt", desc: "Відкрити файл у простому редакторі (зберегти: Ctrl+O, вийти: Ctrl+X)." },
      { cmd: "vim config.txt", desc: "Відкрити файл у vim." },
      { cmd: "i", desc: "(У vim) Перейти в режим вставки (редагування)." },
      { cmd: ":wq", desc: "(У vim) Зберегти та вийти (натиснути Esc перед цим)." },
      { cmd: ":q!", desc: "(У vim) Вийти без збереження змін." }
    ],
    mission: "Створіть файл 'orders.txt' за допомогою nano, напишіть там кілька рядків, збережіть і вийдіть. Якщо ви сміливі — спробуйте зробити те саме у vim."
  },
  {
    day: 19,
    title: "Автоматизація зброї (Скрипти резервного копіювання)",
    description: "Написання простих bash-скриптів для бекапів.",
    theory: "Bash-скриптинг — це мистецтво автоматизації. Скрипт — це просто текстовий файл, що містить послідовність команд Linux, які виконуються інтерпретатором (оболонкою Bash) одна за одною. В умовах стресу та дефіциту часу ручне введення довгих команд неминуче призводить до помилок. Автоматизація рутинних задач, таких як збір розвідданих, налаштування мережі або створення резервних копій (бекапів), гарантує точність та стабільність результату. Скрипти можуть використовувати змінні для зберігання даних (наприклад, поточної дати для іменування архівів) та приймати аргументи, що робить їх гнучкими інструментами багаторазового використання.",
    commands: [
      { cmd: "#!/bin/bash", desc: "Шебанг — вказує системі, що це bash-скрипт." },
      { cmd: "SRC=\"/etc\"", desc: "Змінна з директорією для копіювання." },
      { cmd: "DEST=\"/backup/etc_$(date +%F).tar.gz\"", desc: "Формування імені файлу з поточною датою." },
      { cmd: "tar -czf $DEST $SRC", desc: "Команда створення архіву всередині скрипта." }
    ],
    mission: "Напишіть скрипт 'backup_intel.sh', який архівує вміст директорії '~/intel_data' (створіть її та додайте кілька файлів) у файл '~/backup_intel_ПОТОЧНА_ДАТА.tar.gz'. Зробіть скрипт виконуваним (chmod +x) та запустіть його."
  },
  {
    day: 20,
    title: "Розумна зброя (Моніторинг ресурсів)",
    description: "Скрипти з умовами для перевірки стану системи.",
    theory: "Справжня автоматизація починається тоді, коли скрипти здатні приймати рішення на основі поточного стану системи. Використання умовних операторів (`if`, `then`, `else`) та циклів (`for`, `while`) перетворює просту послідовність команд на 'розумну' програму. Наприклад, скрипт може перевірити код повернення попередньої команди (`$?`): якщо пінг до сервера успішний, скрипт продовжує роботу, якщо ні — ініціює перезапуск мережевого інтерфейсу. Цикли дозволяють виконувати одну й ту саму дію для списку об'єктів (наприклад, просканувати діапазон IP-адрес або обробити всі лог-файли в директорії). Це основа для створення систем самодіагностики та моніторингу.",
    commands: [
      { cmd: "df -h / | awk 'NR==2 {print $5}' | sed 's/%//'", desc: "Отримати відсоток зайнятого місця на диску." },
      { cmd: "if [ $USAGE -gt 90 ]; then echo 'CRITICAL'; fi", desc: "Умова перевірки: якщо більше 90%." },
      { cmd: "free -m", desc: "Перевірка оперативної пам'яті." }
    ],
    mission: "Напишіть скрипт 'sys_monitor.sh', який перевіряє використання диска. Якщо зайнято більше 80% місця, скрипт повинен виводити 'УВАГА: Диск майже повний!', інакше — 'Диск у нормі'. (Підказка: використовуйте df -h)."
  },
  {
    day: 21,
    title: "Автономна робота (Обробка логів та cron)",
    description: "Автоматизація задач за розкладом.",
    theory: "Планувальник задач `cron` — це механізм, який забезпечує повну автономність систем. Він дозволяє виконувати скрипти та команди за чітко визначеним розкладом: щохвилини, щогодини, щодня о певній годині або в конкретні дні тижня. Для військових систем це означає можливість налаштувати автоматичну ротацію логів, нічне резервне копіювання баз даних, періодичну перевірку цілісності файлів або відправку звітів про стан системи без втручання людини. Синтаксис `crontab` складається з п'яти полів часу та команди. Правильне налаштування cron перетворює ваш сервер з інструменту, що вимагає постійної уваги, на надійного автономного помічника.",
    commands: [
      { cmd: "grep 'Failed password' /var/log/auth.log > /tmp/alerts.txt", desc: "Збір підозрілих подій з логів." },
      { cmd: "crontab -e", desc: "Відкрити файл розкладу поточного користувача для редагування." },
      { cmd: "0 * * * * /root/sys_monitor.sh", desc: "Приклад cron: запуск скрипта щогодини." },
      { cmd: "59 23 * * * /path/to/backup.sh", desc: "Приклад cron: запуск щодня о 23:59." }
    ],
    mission: "Створіть скрипт 'log_check.sh', який шукає слово 'error' у файлі /var/log/syslog і записує знайдені рядки у '~/daily_errors.txt'. Додайте цей скрипт у crontab для автоматичного виконання щодня о 23:59."
  }
];
